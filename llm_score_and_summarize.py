import os
import json
import glob
import requests
import smtplib
import re
from datetime import date
from pathlib import Path
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# -----------------------------
# CONFIG
# -----------------------------
AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT")
AZURE_OPENAI_API_KEY = os.getenv("AZURE_OPENAI_API_KEY")

# Deployment name - change this to match your Azure OpenAI deployment name
DEPLOYMENT_NAME = os.getenv("AZURE_OPENAI_DEPLOYMENT", "gpt-5.2-chat")

# API version - required for Azure OpenAI
API_VERSION = os.getenv("AZURE_OPENAI_API_VERSION", "2024-02-15-preview")

# Email configuration
ICLOUD_EMAIL = os.getenv("ICLOUD_EMAIL")
ICLOUD_PASSWORD = os.getenv("ICLOUD_PASSWORD")  # App-specific password
EMAIL_RECIPIENT = os.getenv("EMAIL_RECIPIENT", ICLOUD_EMAIL)  # Default to sender if not set

# Output directory structure: json_output/YYYY-MM-DD/hermes_llm_top3_YYYY-MM-DD.json
today = date.today().isoformat()
OUTPUT_DIR = Path("json_output") / today
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)  # Create directory if it doesn't exist
OUTPUT_FILE = OUTPUT_DIR / f"hermes_llm_top3_{today}.json"

# -----------------------------
# VALIDATION
# -----------------------------
if not AZURE_OPENAI_ENDPOINT or not AZURE_OPENAI_API_KEY:
    raise EnvironmentError(
        "Missing AZURE_OPENAI_ENDPOINT or AZURE_OPENAI_API_KEY environment variables"
    )

# -----------------------------
# HELPERS
# -----------------------------
def load_articles():
    files = sorted(glob.glob("hermes_signal_*.json"), reverse=True)

    if not files:
        raise FileNotFoundError("No hermes_relay_*.json files found")

    latest_file = files[0]
    print(f"Loading articles from: {latest_file}")

    with open(latest_file, "r") as f:
        return json.load(f)


def build_prompt(articles):
    return f"""
You are a senior cybersecurity analyst advising executives.

Task:
- Score each article from 1‚Äì10 based on business risk, reputational damage, and executive concern.
- Select the top 3.
- For each article, provide in this EXACT format (use "---" to separate each article):

1) [Headline - use exact title from article]
Score: [X]/10

Key Takeaways:
- [2-3 short, critical bullet points only - most important points]

Board-Level Impact:
[Write 2-3 paragraphs explaining why the board should care. Focus on:
- Financial exposure (potential costs, fines, revenue impact)
- Reputational risk (customer trust, brand damage, media attention)
- Regulatory/legal exposure (compliance issues, lawsuits, regulatory fines)
- Strategic risk (competitive disadvantage, market position)
Write this as a board briefing - direct, factual, focused on business consequences]

LinkedIn Post (Ready to Copy/Paste):
[Write a 3-4 paragraph LinkedIn post that:
- Sounds like a real human wrote it‚Äînatural, conversational, authentic
- Avoids typical AI language patterns, clich√©s, and formulaic phrases
- Uses varied sentence structure and length (mix short punchy sentences with longer ones)
- Includes personal observations, genuine reactions, or real-world context when appropriate
- Writes as if you're sharing your actual thoughts, not summarizing a report
- Avoids phrases like "it's important to note", "in conclusion", "it's worth mentioning", "this highlights", "this underscores", etc.
- Uses contractions naturally (don't, can't, won't) to sound more human
- Explains business impact in plain executive language (not technical jargon)
- Discusses potential consequences (financial, reputational, operational) naturally
- Ends with a genuine takeaway or question, not a forced call-to-action
- Is ready to copy/paste directly into LinkedIn (no markdown formatting needed)
- Reads like something you'd actually post, not something generated by AI]

---

[Repeat for article 2]

---

[Repeat for article 3]

IMPORTANT: 
- Use the exact article title/headline as it appears in the articles list below
- Use "---" on its own line to separate each of the 3 articles
- Make sure you provide all 3 articles

Articles:
{json.dumps(articles, indent=2)}
"""


def call_llm(prompt):
    # Clean the endpoint URL
    base = AZURE_OPENAI_ENDPOINT.rstrip("/")
    
    # Construct the API URL with API version parameter (required for Azure OpenAI)
    url = f"{base}/openai/deployments/{DEPLOYMENT_NAME}/chat/completions?api-version={API_VERSION}"
    
    print(f"Calling Azure OpenAI endpoint: {url}")
    print(f"Using deployment: {DEPLOYMENT_NAME}")

    headers = {
        "Content-Type": "application/json",
        "api-key": AZURE_OPENAI_API_KEY,
    }

    payload = {
        "messages": [
            {"role": "system", "content": "You are a senior cybersecurity analyst who writes in a natural, human voice. You avoid AI clich√©s and formulaic language. Your writing sounds authentic and conversational, like a real person sharing genuine insights, not an AI summarizing information."},
            {"role": "user", "content": prompt},
        ],
        "temperature": 1,
    }

    response = requests.post(url, headers=headers, json=payload)
    try:
        response.raise_for_status()
    except requests.HTTPError:
        print(f"LLM request failed: {response.status_code}")
        print(f"Response: {response.text}")
        print(f"URL called: {url}")
        # Write a helpful error file for debugging
        with open(OUTPUT_FILE, "w") as f:
            json.dump({
                "error": "LLM request failed", 
                "status": response.status_code, 
                "response": response.text,
                "url": url,
                "deployment": DEPLOYMENT_NAME
            }, f, indent=2)
        import sys
        sys.exit(1)

    return response.json()["choices"][0]["message"]["content"]


def match_headline_to_article(headline, articles):
    """Match a headline from LLM response to the original article to get the link."""
    # Try exact match first
    for article in articles:
        if article["title"].strip() == headline.strip():
            return article["link"]
    
    # Try case-insensitive match
    for article in articles:
        if article["title"].strip().lower() == headline.strip().lower():
            return article["link"]
    
    # Try partial match (headline contains article title or vice versa)
    for article in articles:
        title_lower = article["title"].strip().lower()
        headline_lower = headline.strip().lower()
        if title_lower in headline_lower or headline_lower in title_lower:
            return article["link"]
    
    return None


def format_email_html(llm_response, articles):
    """Convert LLM markdown response to HTML email with article links."""
    html_content = f"""
    <html>
    <head>
        <style>
            body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; }}
            .container {{ background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
            h1 {{ color: #1a1a1a; border-bottom: 3px solid #007AFF; padding-bottom: 10px; margin-top: 0; }}
            h2 {{ color: #2c3e50; margin-top: 30px; margin-bottom: 15px; }}
            .article {{ background: #f8f9fa; border-left: 4px solid #007AFF; padding: 20px; margin: 25px 0; border-radius: 4px; }}
            .score {{ font-size: 20px; font-weight: bold; color: #007AFF; margin: 15px 0; }}
            ul {{ margin: 15px 0; padding-left: 25px; }}
            li {{ margin: 10px 0; }}
            .link {{ color: #007AFF; text-decoration: none; font-weight: 600; }}
            .link:hover {{ text-decoration: underline; }}
            .executive-note {{ background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 15px 0; border-radius: 4px; }}
            .linkedin-ready {{ background: #e3f2fd; border: 2px dashed #2196F3; padding: 20px; margin: 20px 0; border-radius: 4px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }}
            .linkedin-ready h3 {{ color: #1976D2; margin-top: 0; font-size: 16px; }}
            .linkedin-ready .copy-text {{ background: white; padding: 15px; border-radius: 4px; white-space: pre-wrap; font-size: 15px; line-height: 1.7; color: #333; }}
            .footer {{ margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; font-size: 14px; text-align: center; }}
            p {{ margin: 10px 0; }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>üîí Daily Cybersecurity Briefing</h1>
            <p><strong>Date:</strong> {date.today().strftime('%B %d, %Y')}</p>
    """
    
    # Split response into sections by "---" (on its own line)
    # Handle both "\n---\n" and "\n---" patterns
    sections = re.split(r'\n---\s*\n', llm_response)
    if len(sections) == 1:
        # Try alternative splitting
        sections = re.split(r'\n---\n', llm_response)
    
    article_count = 0
    for section in sections:
        if not section.strip():
            continue
        
        # Try multiple headline patterns
        headline = None
        
        # Pattern 1: Numbered format "1) Title" or "1. Title" at start
        headline_match = re.search(r'^\d+[\)\.]\s*(.+?)(?:\n|$)', section, re.MULTILINE)
        if headline_match:
            headline = headline_match.group(1).strip()
        else:
            # Pattern 2: "Headline: **text**" or "Headline: text"
            headline_match = re.search(r'Headline:\s*\*\*(.+?)\*\*|Headline:\s*(.+?)(?:\n|$)', section, re.IGNORECASE | re.DOTALL)
            if headline_match:
                headline = (headline_match.group(1) or headline_match.group(2)).strip()
            else:
                # Pattern 3: Bold text at start of section
                headline_match = re.search(r'^\*\*(.+?)\*\*', section, re.MULTILINE)
                if headline_match:
                    headline = headline_match.group(1).strip()
        
        if headline:
            headline = headline.strip('*').strip()
            article_count += 1
            
            # Find matching article link
            article_link = match_headline_to_article(headline, articles)
            
            # Start article div
            if article_link:
                html_content += f'<div class="article"><h2><a href="{article_link}" class="link" target="_blank">{headline}</a></h2>\n'
            else:
                html_content += f'<div class="article"><h2>{headline}</h2>\n'
            
            # Extract score - try multiple patterns
            score = None
            score_match = re.search(r'Score:\s*(\d+(?:\.\d+)?)\s*/?\s*10|Score:\s*\*\*(\d+(?:\.\d+)?)/10\*\*|\*\*(\d+(?:\.\d+)?)/10\*\*', section)
            if score_match:
                score = score_match.group(1) or score_match.group(2) or score_match.group(3)
            
            if score:
                html_content += f'<div class="score">Score: {score}/10</div>\n'
            
            # Extract Key Takeaways bullets (limit to 2-3)
            takeaways_match = re.search(r'Key Takeaways?:(.+?)(?=Board-Level Impact|LinkedIn Post|$)', section, re.IGNORECASE | re.DOTALL)
            bullets = []
            if takeaways_match:
                takeaways_text = takeaways_match.group(1)
                bullets = re.findall(r'[-‚Ä¢]\s*(.+?)(?=\n|$)', takeaways_text, re.MULTILINE)
            else:
                # Fallback: look for bullets before "Board-Level Impact" or "LinkedIn Post"
                bullets_match = re.search(r'^[-‚Ä¢]\s*(.+?)$', section, re.MULTILINE)
                if bullets_match:
                    all_bullets = re.findall(r'^[-‚Ä¢]\s*(.+?)$', section, re.MULTILINE)
                    # Take first 3 bullets
                    bullets = [b.strip() for b in all_bullets[:3] if b.strip() and len(b.strip()) > 5]
            
            if bullets:
                html_content += '<ul>\n'
                for bullet in bullets[:3]:  # Limit to 3 bullets
                    bullet = bullet.strip()
                    if bullet and len(bullet) > 5:
                        html_content += f'<li>{bullet}</li>\n'
                html_content += '</ul>\n'
            
            # Extract Board-Level Impact section
            board_match = re.search(r'Board-Level Impact:(.+?)(?=LinkedIn Post|$)', section, re.IGNORECASE | re.DOTALL)
            if board_match:
                board_text = board_match.group(1).strip()
                # Convert newlines to <br> for HTML display
                board_text_html = board_text.replace('\n', '<br>')
                # Convert markdown bold to HTML
                board_text_html = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', board_text_html)
                
                html_content += f'''
                <div class="executive-note">
                    <strong>Board-Level Impact:</strong><br>
                    {board_text_html}
                </div>
                '''
            
            # Extract LinkedIn Post section
            linkedin_match = re.search(r'LinkedIn Post[^:]*:(.+?)(?=\n---|$)', section, re.IGNORECASE | re.DOTALL)
            if linkedin_match:
                linkedin_text = linkedin_match.group(1).strip()
                # Clean up the text - remove markdown formatting for LinkedIn
                linkedin_text_clean = linkedin_text.replace('**', '').replace('*', '').strip()
                # Format paragraphs (split on double newlines)
                paragraphs = [p.strip() for p in linkedin_text_clean.split('\n\n') if p.strip()]
                linkedin_text_formatted = '\n\n'.join(paragraphs)
                
                html_content += f'''
                <div class="linkedin-ready">
                    <h3>üì± LinkedIn Post (Ready to Copy/Paste)</h3>
                    <div class="copy-text">{linkedin_text_formatted}</div>
                </div>
                '''
            
            html_content += '</div>\n'
    
    # Debug: print how many articles were found
    if article_count == 0:
        print(f"Warning: No articles found in response. Response length: {len(llm_response)}")
        print(f"First 500 chars: {llm_response[:500]}")
    
    html_content += """
            <div class="footer">
                <p>Generated by Hermes Relay - Your daily cybersecurity intelligence briefing</p>
            </div>
        </div>
    </body>
    </html>
    """
    
    return html_content


def send_email(html_content, subject="Daily Cybersecurity Briefing"):
    """Send email via iCloud SMTP."""
    if not ICLOUD_EMAIL or not ICLOUD_PASSWORD:
        print("Email credentials not configured. Skipping email send.")
        print("Set ICLOUD_EMAIL and ICLOUD_PASSWORD environment variables to enable email.")
        return False
    
    try:
        # Create message
        msg = MIMEMultipart('alternative')
        msg['Subject'] = f"{subject} - {date.today().strftime('%B %d, %Y')}"
        msg['From'] = ICLOUD_EMAIL
        msg['To'] = EMAIL_RECIPIENT
        
        # Create HTML part
        html_part = MIMEText(html_content, 'html')
        msg.attach(html_part)
        
        # Send email via iCloud SMTP
        print(f"Sending email to {EMAIL_RECIPIENT}...")
        print(f"Using SMTP server: smtp.mail.me.com:587")
        print(f"Email address: {ICLOUD_EMAIL}")
        print(f"Password length: {len(ICLOUD_PASSWORD) if ICLOUD_PASSWORD else 0} characters")
        
        with smtplib.SMTP('smtp.mail.me.com', 587) as server:
            print("Connecting to SMTP server...")
            server.set_debuglevel(1)  # Enable debug output
            print("Starting TLS...")
            server.starttls()
            print(f"Attempting login with email: {ICLOUD_EMAIL}")
            server.login(ICLOUD_EMAIL, ICLOUD_PASSWORD)
            print("Login successful! Sending message...")
            server.send_message(msg)
        
        print("Email sent successfully!")
        return True
    except smtplib.SMTPAuthenticationError as e:
        print(f"‚ùå SMTP Authentication Failed!")
        print(f"Error details: {e}")
        print(f"\nTroubleshooting steps:")
        print(f"1. Verify ICLOUD_EMAIL is correct: {ICLOUD_EMAIL}")
        print(f"2. Verify ICLOUD_PASSWORD is an app-specific password (not your regular password)")
        print(f"3. Check that 2FA is enabled on your Apple ID")
        print(f"4. Generate a new app-specific password at: https://appleid.apple.com")
        print(f"5. Make sure there are no extra spaces in your .env file")
        return False
    except smtplib.SMTPException as e:
        print(f"‚ùå SMTP Error: {e}")
        print(f"Error code: {e.smtp_code if hasattr(e, 'smtp_code') else 'N/A'}")
        print(f"Error message: {e.smtp_error if hasattr(e, 'smtp_error') else str(e)}")
        return False
    except Exception as e:
        print(f"‚ùå Failed to send email: {type(e).__name__}: {e}")
        import traceback
        print(f"Full traceback:")
        traceback.print_exc()
        return False


# -----------------------------
# MAIN
# -----------------------------
def main():
    # Check if HTML or JSON file already exists for today
    html_file = OUTPUT_DIR / f"hermes_briefing_{today}.html"
    
    if html_file.exists():
        print(f"Found existing HTML file: {html_file}")
        print("Reading existing HTML and sending email...")
        with open(html_file, "r", encoding="utf-8") as f:
            html_email = f.read()
        send_email(html_email)
        print("Done! Email sent from existing file.")
        return
    
    # Check if JSON exists (in case HTML was deleted but JSON remains)
    if OUTPUT_FILE.exists():
        print(f"Found existing JSON file: {OUTPUT_FILE}")
        print("Loading existing data and generating HTML...")
        with open(OUTPUT_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        
        # Load articles to match headlines to links
        articles = load_articles()
        
        # Generate HTML from existing JSON
        html_email = format_email_html(data["top_articles"], articles)
        
        # Save HTML
        with open(html_file, "w", encoding="utf-8") as f:
            f.write(html_email)
        print(f"Saved HTML ‚Üí {html_file}")
        
        # Send email
        send_email(html_email)
        print("Done! Email sent from regenerated HTML.")
        return
    
    # No existing files - generate new summaries
    print("No existing files found. Generating new summaries...")
    articles = load_articles()
    prompt = build_prompt(articles)

    print("Calling Azure OpenAI‚Ä¶")
    result = call_llm(prompt)

    # Save JSON output (for backup/debugging)
    with open(OUTPUT_FILE, "w") as f:
        json.dump(
            {
                "date": date.today().isoformat(),
                "top_articles": result,
            },
            f,
            indent=2,
        )
    print(f"Saved output ‚Üí {OUTPUT_FILE}")

    # Format as HTML email and send
    html_email = format_email_html(result, articles)
    
    # Save HTML to the same directory as JSON
    with open(html_file, "w", encoding="utf-8") as f:
        f.write(html_email)
    print(f"Saved HTML ‚Üí {html_file}")
    
    send_email(html_email)
    print("Done! New summaries generated and email sent.")


if __name__ == "__main__":
    main()